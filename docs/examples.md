---
title: Examples
description: Using openapi-typescript in real-world applications
---

# Examples

The types generated by openapi-typescript are universal, and can be used in a variety of ways. While these examples are not comprehensive, hopefully they‚Äôll spark ideas about how to use these in your app.

## Data fetching

Fetching data can be done simply and safely using an **automatically-typed fetch wrapper**:

- [openapi-fetch](/openapi-fetch/) (recommended)
- [openapi-typescript-fetch](https://www.npmjs.com/package/openapi-typescript-fetch) by [@ajaishankar](https://github.com/ajaishankar)

::: tip

A good fetch wrapper should **never use generics.** Generics require more typing and can hide errors!

:::

## Hono

[Hono](https://hono.dev/) is a modern server framework for Node.js that can be deployed to the edge (e.g. [Cloudflare Workers](https://developers.cloudflare.com/workers/)) just as easily as a standard container. It also has TypeScript baked-in, so it‚Äôs a great fit for generated types.

After [generating your types using the CLI](/introduction), pass in the proper `paths` response for each endpoint:

```ts
import { Hono } from "hono";
import { components, paths } from "./path/to/my/types";

const app = new Hono();

/** /users */
app.get("/users", async (ctx) => {
  try {
    const users = db.get("SELECT * from users");
    return ctx.json<
      paths["/users"]["responses"][200]["content"]["application/json"]
    >(users);
  } catch (err) {
    return ctx.json<components["schemas"]["Error"]>({
      status: 500,
      message: err ?? "An error occurred",
    });
  }
});

export default app;
```

::: tip

TypeChecking in server environments can be tricky, as you‚Äôre often querying databases and talking to other endpoints that TypeScript can‚Äôt introspect. But using generics will alert you of the obvious errors that TypeScript _can_ catch (and more things in your stack may have types than you¬†realize!).

:::

## Mock-Service-Worker (MSW)

If you are using [Mock Service Worker (MSW)](https://mswjs.io) to define your API mocks, you can use a **small, automatically-typed wrapper** around MSW, which enables you to address conflicts in your API mocks easily when your OpenAPI specification changes. Ultimately, you can have the same level of confidence in your application's API client **and** API mocks.

Using `openapi-typescript` and a wrapper around fetch, such as `openapi-fetch`, ensures that our application's API client does not have conflicts with your OpenAPI specification.

However, while you can address issues with the API client easily, you have to "manually" remember to adjust API mocks since there is no mechanism that warns you about conflicts.

We recommend the following wrapper, which works flawlessly with `openapi-typescript`:

- [openapi-msw](https://www.npmjs.com/package/openapi-msw) by [@christoph-fricke](https://github.com/christoph-fricke)

## Test Mocks

One of the most common causes of false positive tests is when mocks are out-of-date with the actual API¬†responses.

`openapi-typescript` offers a fantastic way to guard against this with minimal effort. Here‚Äôs one example how you could write your own helper function to typecheck all mocks to match your OpenAPI schema (we‚Äôll use [vitest](https://vitest.dev/)/[vitest-fetch-mock](https://www.npmjs.com/package/vitest-fetch-mock) but the same principle could work for any setup):

Let‚Äôs say we want to write our mocks in the following object structure, so we can mock multiple endpoints at once:

```ts
{
  [pathname]: {
    [HTTP method]: { status: [status], body: { ‚Ä¶[some mock data] } };
  }
}
```

Using our generated types we can then infer **the correct data shape** for any given path + HTTP method + status code. An example test would look like this:

::: code-group [my-test.test.ts]

```ts
import { mockResponses } from "../test/utils";

describe("My API test", () => {
  it("mocks correctly", async () => {
    mockResponses({
      "/users/{user_id}": {
        // ‚úÖ Correct 200 response
        get: { status: 200, body: { id: "user-id", name: "User Name" } },
        // ‚úÖ Correct 403 response
        delete: { status: 403, body: { code: "403", message: "Unauthorized" } },
      },
      "/users": {
        // ‚úÖ Correct 201 response
        put: { 201: { status: "success" } },
      },
    });

    // test 1: GET /users/{user_id}: 200
    await fetch("/users/user-123");

    // test 2: DELETE /users/{user_id}: 403
    await fetch("/users/user-123", { method: "DELETE" });

    // test 3: PUT /users: 200
    await fetch("/users", {
      method: "PUT",
      body: JSON.stringify({ id: "new-user", name: "New User" }),
    });

    // test cleanup
    fetchMock.resetMocks();
  });
});
```

:::

_Note: this example uses a vanilla `fetch()` function, but any fetch wrapper‚Äîincluding [openapi-fetch](/openapi-fetch/)‚Äîcould be dropped in instead without any changes._

And the magic that produces this would live in a `test/utils.ts` file that can be copy + pasted where desired (hidden for simplicity):

<details>
<summary>üìÑ <strong>test/utils.ts</strong></summary>

::: code-group [test/utils.ts]

```ts
import { paths } from "./api/v1/my-schema"; // generated by openapi-typescript

// Settings
// ‚ö†Ô∏è Important: change this! This prefixes all URLs
const BASE_URL = "https://myapi.com/v1";
// End Settings

// type helpers ‚Äî ignore these; these just make TS lookups better
type FilterKeys<Obj, Matchers> = {
  [K in keyof Obj]: K extends Matchers ? Obj[K] : never;
}[keyof Obj];
type PathResponses<T> = T extends { responses: any } ? T["responses"] : unknown;
type OperationContent<T> = T extends { content: any } ? T["content"] : unknown;
type MediaType = `${string}/${string}`;
type MockedResponse<T, Status extends keyof T = keyof T> = FilterKeys<
  OperationContent<T[Status]>,
  MediaType
> extends never
  ? { status: Status; body?: never }
  : {
      status: Status;
      body: FilterKeys<OperationContent<T[Status]>, MediaType>;
    };

/**
 * Mock fetch() calls and type against OpenAPI schema
 */
export function mockResponses(responses: {
  [Path in keyof Partial<paths>]: {
    [Method in keyof Partial<paths[Path]>]: MockedResponse<
      PathResponses<paths[Path][Method]>
    >;
  };
}) {
  fetchMock.mockResponse((req) => {
    const mockedPath = findPath(
      req.url.replace(BASE_URL, ""),
      Object.keys(responses),
    )!;
    // note: we get lazy with the types here, because the inference is bad anyway and this has a `void` return signature. The important bit is the parameter signature.
    if (!mockedPath || (!responses as any)[mockedPath])
      throw new Error(`No mocked response for ${req.url}`); // throw error if response not mocked (remove or modify if you‚Äôd like different behavior)
    const method = req.method.toLowerCase();
    if (!(responses as any)[mockedPath][method])
      throw new Error(`${req.method} called but not mocked on ${mockedPath}`); // likewise throw error if other parts of response aren‚Äôt mocked
    if (!(responses as any)[mockedPath][method]) {
      throw new Error(`${req.method} called but not mocked on ${mockedPath}`);
    }
    const { status, body } = (responses as any)[mockedPath][method];
    return { status, body: JSON.stringify(body) };
  });
}

// helper function that matches a realistic URL (/users/123) to an OpenAPI path (/users/{user_id}
export function findPath(
  actual: string,
  testPaths: string[],
): string | undefined {
  const url = new URL(
    actual,
    actual.startsWith("http") ? undefined : "http://testapi.com",
  );
  const actualParts = url.pathname.split("/");
  for (const p of testPaths) {
    let matched = true;
    const testParts = p.split("/");
    if (actualParts.length !== testParts.length) continue; // automatically not a match if lengths differ
    for (let i = 0; i < testParts.length; i++) {
      if (testParts[i]!.startsWith("{")) continue; // path params ({user_id}) always count as a match
      if (actualParts[i] !== testParts[i]) {
        matched = false;
        break;
      }
    }
    if (matched) return p;
  }
}
```

:::

::: info Additional Explanation

That code is quite above is quite a doozy! For the most part, it‚Äôs a lot of implementation detail you can ignore. The `mockResponses(‚Ä¶)` function signature is where all the important magic happens‚Äîyou‚Äôll notice a direct link between this structure and our design. From there, the rest of the code is just making the runtime work as expected.

:::

```ts
export function mockResponses(responses: {
  [Path in keyof Partial<paths>]: {
    [Method in keyof Partial<paths[Path]>]: MockedResponse<
      PathResponses<paths[Path][Method]>
    >;
  };
});
```

</details>

Now, whenever your schema updates, **all your mock data will be typechecked correctly**¬†üéâ. This is a huge step in ensuring resilient, accurate tests.
