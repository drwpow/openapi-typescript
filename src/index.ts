import type { GlobalContext, OpenAPI3, OpenAPITSOptions } from "./types.js";
import type { Readable } from "node:stream";
import { URL } from "node:url";
import load, { resolveSchema, VIRTUAL_JSON_URL } from "./load.js";
import transformSchema from "./transform/index.js";
import { checkOpenAPIVersion, escObjKey, indent } from "./utils.js";
export * from "./types.js"; // expose all types to consumers

const EMPTY_OBJECT_RE = /^\s*\{?\s*\}?\s*$/;

export const COMMENT_HEADER = `/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

`;

/**
 * This function is the entry to the program and allows the user to pass in a remote schema and/or local schema.
 * The URL or schema and headers can be passed in either programmatically and/or via the CLI.
 * Remote schemas are fetched from a server that supplies JSON or YAML format via an HTTP GET request. File based schemas
 * are loaded in via file path, most commonly prefixed with the file:// format. Alternatively, the user can pass in
 * OpenAPI2 or OpenAPI3 schema objects that can be parsed directly by the function without reading the file system.
 *
 * Function overloading is utilized for generating stronger types for our different schema types and option types.
 *
 * @param {string} schema Root Swagger Schema HTTP URL, File URL, and/or JSON or YAML schema
 * @param {SwaggerToTSOptions<typeof schema>} [options] Options to specify to the parsing system
 * @return {Promise<string>}  {Promise<string>} Parsed file schema
 */
async function openapiTS(
  schema: string | URL | OpenAPI3 | Readable,
  options: OpenAPITSOptions = {} as Partial<OpenAPITSOptions>
): Promise<string> {
  const ctx: GlobalContext = {
    additionalProperties: options.additionalProperties || false,
    alphabetize: options.alphabetize || false,
    defaultNonNullable: options.defaultNonNullable || false,
    discriminators: {},
    transform: options && typeof options.transform === "function" ? options.transform : undefined,
    postTransform: options && typeof options.postTransform === "function" ? options.postTransform : undefined,
    immutableTypes: options.immutableTypes || false,
    indentLv: 0,
    pathParamsAsTypes: options.pathParamsAsTypes || false,
    silent: options.silent || false,
    supportArrayLength: options.supportArrayLength || false,
  };

  // note: we may be loading many large schemas into memory at once; take care to reuse references without cloning
  const isInlineSchema = typeof schema !== "string" && schema instanceof URL == false;

  // 1. load schema (and subschemas)
  let rootSchema = {} as OpenAPI3;
  const external: { [id: string]: OpenAPI3 } = {};
  const allSchemas: { [id: string]: OpenAPI3 } = {};
  const schemaURL: URL = typeof schema === "string" ? resolveSchema(schema) : (schema as URL);

  await load(schemaURL, {
    ...ctx,
    auth: options.auth,
    schemas: allSchemas,
    rootURL: isInlineSchema ? new URL(VIRTUAL_JSON_URL) : schemaURL, // if an inline schema is passed, use virtual URL
    httpHeaders: options.httpHeaders,
    httpMethod: options.httpMethod,
  });

  // 1a. identify root schema
  for (const k of Object.keys(allSchemas)) {
    const rootSchemaID = isInlineSchema ? VIRTUAL_JSON_URL : schemaURL.href;
    if (k === rootSchemaID) {
      rootSchema = allSchemas[k];
    } else {
      external[k] = allSchemas[k];
    }

    // 1b. make sure schema version is valid
    checkOpenAPIVersion(allSchemas[k] as any);

    // 1c. garbage collect things we no longer need
    delete allSchemas[k];
  }

  // 2. generate raw output
  const output: string[] = [];

  // 2a. Start file, inject custom code (if any)
  if (options && "commentHeader" in options) {
    if (options.commentHeader) output.push(options.commentHeader);
  } else {
    output.push(COMMENT_HEADER);
  }

  // 2b. OneOf helper (@see https://github.com/Microsoft/TypeScript/issues/14094#issuecomment-723571692)
  output.push(
    "/** Type helpers */",
    "type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };",
    "type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;",
    "type OneOf<T extends any[]> = T extends [infer Only] ? Only : T extends [infer A, infer B, ...infer Rest] ? OneOf<[XOR<A, B>, ...Rest]> : never;",
    ""
  );

  // 2c. options.inject
  if (options.inject) output.push(options.inject);

  // 2d. root schema
  const rootTypes = transformSchema(rootSchema, { ...ctx });
  for (const k of Object.keys(rootTypes)) {
    if (rootTypes[k] && !EMPTY_OBJECT_RE.test(rootTypes[k])) {
      output.push(
        options.exportType ? `export type ${k} = ${rootTypes[k]};` : `export interface ${k} ${rootTypes[k]}`,
        ""
      );
    } else {
      output.push(`export type ${k} = Record<string, never>;`, "");
    }
  }

  // 2e. external schemas (subschemas)
  const externalKeys = Object.keys(external);
  if (externalKeys.length) {
    output.push(options.exportType ? "export type external = {" : "export interface external {", "");
    externalKeys.sort((a, b) => a.localeCompare(b, "en", { numeric: true })); // sort external keys because they may have resolved in a different order each time
    for (const subschemaURL of externalKeys) {
      output.push(indent(`${escObjKey(subschemaURL)}: {`, 1), "");
      const subschemaTypes = transformSchema(external[subschemaURL], {
        ...ctx,
        indentLv: 1,
        subschemaID: subschemaURL,
      });
      for (const k of Object.keys(subschemaTypes)) {
        output.push(indent(`${escObjKey(k)}: ${subschemaTypes[k]}`, 2));
      }
      output.push(indent("}", 1));
    }
    output.push(`}${options.exportType ? ";" : ""}`, "");
  } else {
    output.push(`export type external = Record<string, never>;`, "");
  }

  return output.join("\n");
}

export default openapiTS;
