import fs from "node:fs";
import { OpenAPI3 } from "../src/types";
import openapiTS from "../dist/index.js";

const BOILERPLATE = `/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


/** Type helpers */
type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };
type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;
type OneOf<T extends any[]> = T extends [infer Only] ? Only : T extends [infer A, infer B, ...infer Rest] ? OneOf<[XOR<A, B>, ...Rest]> : never;
`;

beforeAll(() => {
  vi.spyOn(process, "exit").mockImplementation(((code: number) => {
    throw new Error(`Process exited with error code ${code}`);
  }) as any);
});

describe("openapiTS", () => {
  beforeAll(() => {
    vi.spyOn(process, "exit").mockImplementation((() => {}) as any);
  });

  describe("3.0", () => {
    test("custom properties", async () => {
      const generated = await openapiTS({
        openapi: "3.0",
        info: { title: "Test", version: "1.0" },
        components: {
          schemas: {
            Base: {
              type: "object",
              additionalProperties: { type: "string" },
            },
            SchemaType: {
              oneOf: [{ $ref: "#/components/schemas/Base" }, { $ref: "#/x-swagger-bake/components/schemas/Extension" }],
            },
          },
        },
      });
      expect(generated).toBe(`${BOILERPLATE}
export type paths = Record<string, never>;

export interface components {
  schemas: {
    Base: {
      [key: string]: string | undefined;
    };
    SchemaType: components["schemas"]["Base"];
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type external = Record<string, never>;

export type operations = Record<string, never>;
`);
    });
  });

  describe("3.1", () => {
    test("discriminator", async () => {
      const schema: OpenAPI3 = {
        openapi: "3.1",
        info: { title: "test", version: "1.0" },
        components: {
          schemas: {
            Pet: {
              type: "object",
              required: ["petType"],
              properties: { petType: { type: "string" } },
              discriminator: { propertyName: "petType", mapping: { dog: "Dog" } },
            },
            Cat: {
              allOf: [
                { $ref: "#/components/schemas/Pet" },
                {
                  type: "object",
                  properties: { name: { type: "string" } },
                },
              ],
            },
            Dog: {
              allOf: [
                { $ref: "#/components/schemas/Pet" },
                {
                  type: "object",
                  properties: { bark: { type: "string" } },
                },
              ],
            },
            Lizard: {
              allOf: [
                { $ref: "#/components/schemas/Pet" },
                {
                  type: "object",
                  properties: { lovesRocks: { type: "boolean" } },
                },
              ],
            },
          },
        },
      };
      const generated = await openapiTS(schema);
      expect(generated).toBe(`${BOILERPLATE}
export type paths = Record<string, never>;

export interface components {
  schemas: {
    Pet: {
      petType: string;
    };
    Cat: {
      petType: "Cat";
    } & Omit<components["schemas"]["Pet"], "petType"> & {
      name?: string;
    };
    Dog: {
      petType: "dog";
    } & Omit<components["schemas"]["Pet"], "petType"> & {
      bark?: string;
    };
    Lizard: {
      petType: "Lizard";
    } & Omit<components["schemas"]["Pet"], "petType"> & {
      lovesRocks?: boolean;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type external = Record<string, never>;

export type operations = Record<string, never>;
`);
    });

    test("$ref properties", async () => {
      const schema: OpenAPI3 = {
        openapi: "3.1",
        info: { title: "Test", version: "1.0" },
        components: {
          schemas: {
            ObjRef: {
              type: "object",
              properties: {
                base: { $ref: "#/components/schemas/Entity/properties/foo" },
              },
            },
            AllOf: {
              allOf: [
                { $ref: "#/components/schemas/Entity/properties/foo" },
                { $ref: "#/components/schemas/Thingy/properties/bar" },
              ],
            },
          },
        },
      };
      const generated = await openapiTS(schema);
      expect(generated).toBe(`${BOILERPLATE}
export type paths = Record<string, never>;

export interface components {
  schemas: {
    ObjRef: {
      base?: components["schemas"]["Entity"]["foo"];
    };
    AllOf: components["schemas"]["Entity"]["foo"] & components["schemas"]["Thingy"]["bar"];
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type external = Record<string, never>;

export type operations = Record<string, never>;
`);
    });
  });

  describe("options", () => {
    describe("exportTypes", () => {
      test("false", async () => {
        const generated = await openapiTS(
          {
            openapi: "3.1",
            info: { title: "Test", version: "1.0" },
            components: {
              schemas: {
                User: {
                  type: "object",
                  properties: { name: { type: "string" }, email: { type: "string" } },
                  required: ["name", "email"],
                },
              },
            },
          },
          { exportType: false }
        );
        expect(generated).toBe(`${BOILERPLATE}
export type paths = Record<string, never>;

export interface components {
  schemas: {
    User: {
      name: string;
      email: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type external = Record<string, never>;

export type operations = Record<string, never>;
`);
      });

      test("true", async () => {
        const generated = await openapiTS(
          {
            openapi: "3.1",
            info: { title: "Test", version: "1.0" },
            components: {
              schemas: {
                User: {
                  type: "object",
                  properties: { name: { type: "string" }, email: { type: "string" } },
                  required: ["name", "email"],
                },
              },
            },
          },
          { exportType: true }
        );
        expect(generated).toBe(`${BOILERPLATE}
export type paths = Record<string, never>;

export type components = {
  schemas: {
    User: {
      name: string;
      email: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
};

export type external = Record<string, never>;

export type operations = Record<string, never>;
`);
      });
    });

    describe("pathParamsAsTypes", () => {
      const schema: OpenAPI3 = {
        openapi: "3.1",
        info: { title: "Test", version: "1.0" },
        paths: {
          "/user/{user_id}": {
            parameters: [{ name: "user_id", in: "path" }],
          },
        },
      };

      test("false", async () => {
        const generated = await openapiTS(schema, { pathParamsAsTypes: false });
        expect(generated).toBe(`${BOILERPLATE}
export interface paths {
  "/user/{user_id}": {
    parameters: {
      path: {
        user_id: string;
      };
    };
  };
}

export type components = Record<string, never>;

export type external = Record<string, never>;

export type operations = Record<string, never>;
`);
      });

      test("true", async () => {
        const generated = await openapiTS(schema, { pathParamsAsTypes: true });
        expect(generated).toBe(`${BOILERPLATE}
export interface paths {
  [path: \`/user/\${string}\`]: {
    parameters: {
      path: {
        user_id: string;
      };
    };
  };
}

export type components = Record<string, never>;

export type external = Record<string, never>;

export type operations = Record<string, never>;
`);
      });
    });

    describe("transform/postTransform", () => {
      const schema: OpenAPI3 = {
        openapi: "3.1",
        info: { title: "Test", version: "1.0" },
        components: {
          schemas: {
            Date: { type: "string", format: "date-time" },
          },
        },
      };

      test("transform", async () => {
        const generated = await openapiTS(schema, {
          transform(node) {
            if ("format" in node && node.format === "date-time") return "Date";
          },
        });
        expect(generated).toBe(`${BOILERPLATE}
export type paths = Record<string, never>;

export interface components {
  schemas: {
    /** Format: date-time */
    Date: Date;
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type external = Record<string, never>;

export type operations = Record<string, never>;
`);
      });

      test("postTransform (with inject)", async () => {
        const inject = `type DateOrTime = Date | number;\n`;
        const generated = await openapiTS(schema, {
          postTransform(type, options) {
            if (options.path.includes("Date")) return "DateOrTime";
          },
          inject,
        });
        expect(generated).toBe(`${BOILERPLATE}
${inject}
export type paths = Record<string, never>;

export interface components {
  schemas: {
    /** Format: date-time */
    Date: DateOrTime;
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type external = Record<string, never>;

export type operations = Record<string, never>;
`);
      });
    });
  });

  // note: this tests the Node API; the snapshots in cli.test.ts test the CLI
  describe("snapshots", () => {
    const EXAMPLES_DIR = new URL("../examples/", import.meta.url);
    const FIXTURES_DIR = new URL("./fixtures/", import.meta.url);

    describe("GitHub", () => {
      test("default options", async () => {
        const generated = await openapiTS(new URL("./github-api.yaml", FIXTURES_DIR));
        expect(generated).toBe(fs.readFileSync(new URL("./github-api.ts", EXAMPLES_DIR), "utf8"));
      }, 30000);
    });
    describe("GitHub (next)", () => {
      test("default options", async () => {
        const generated = await openapiTS(new URL("./github-api-next.yaml", FIXTURES_DIR));
        expect(generated).toBe(fs.readFileSync(new URL("./github-api-next.ts", EXAMPLES_DIR), "utf8"));
      }, 30000);
    });
    describe("Stripe", () => {
      test("default options", async () => {
        const generated = await openapiTS(new URL("./stripe-api.yaml", FIXTURES_DIR));
        expect(generated).toBe(fs.readFileSync(new URL("./stripe-api.ts", EXAMPLES_DIR), "utf8"));
      }, 30000);
    });
    describe("DigitalOcean", () => {
      test("default options", async () => {
        const generated = await openapiTS(
          new URL("./digital-ocean-api/specification/DigitalOcean-public.v2.yaml", FIXTURES_DIR)
        );
        expect(generated).toBe(fs.readFileSync(new URL("./digital-ocean-api.ts", EXAMPLES_DIR), "utf8"));
      }, 60000);
    });
  });
});
